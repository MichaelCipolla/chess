notes.txt

-> Problem: When we select a piece, we need to constrain its behavior based on the type of piece it is.

    -> State?
        -> Upon picking up a piece, we could transition to different states:
            -> PieceControllerStateMachine
                -> Active
                    -> Bishop
                    -> Queen
                    -> King
                    -> Rook
                    -> Knight
                    -> Pawn
                        -> Inactive

                IPieceState:
                    -> BishopState
                    -> QueenState
                    -> KingState
                    -> RookState
                    -> KnightState
                    -> PawnState

                -> IPieceState()
                    -> validateMove(int index)
                        // Here we can query whether or not there is a piece on the requested index.
                        // We will also need to iterate through all possible moves to determine if there is a piece blocking the path for sliding pieces.
                        
                        -> capturePiece();
                            // Here we will update the ChessData matrix with replacement to create capture
                            // This will also adjust the score? Maybe this justifies having both
                        -> placePiece();
                            // Here we will simply replace blank spaces with our selected piece.
                            
                How do we handle individual piece movements if we aren't using class instantiations for the piece itself?
                    -> We have a state that can support general piece movements, but for a pawn specifically we need to know if this is the first time the pawn is moving.
                        -> If this is the pawn's first move of the game, we can allow it to move 2 spaces.
                        -> If an enemy pawn is attacking one of the 2 spaces, it can capture the friendly pawn "in passing", moving to the space it was attacking.
                    -> We need to know the castle status of the kings as well.
                        -> castling requires:
                            -> the spaces between the king and the respective rook to be empty.
                            -> the spaces between the king and the respective rook cannot be under attack (inclusive of king and rook spaces)
                            -> the king cannot have moved yet.
                            -> the target friendly rook cannot have moved yet.

                            -> We could use a "special move byte"
                                -> If piece is a:
                                    -> Pawn
                                    -> King
                                   We can add an extra byte to our datagram to indicate whether or not the unit has used up its special move
                                    -> This byte could simply track if a piece has moved before:
                                        -> This would be useful since we need to know if the King OR Rook have moved for the sake of castling
                                        -> Both castling and fast pawn moves require that the piece has not moved yet.
                                            -> Current datagram:
                                                
                Scratching all of the above and redesigning the way we handle piece movement. Created a behavior class which will be attached to a chess piece class object. This is a more practical
                way to handle movement I believe.

                What I need to do:
                    Create a chess piece class. Should be generic. Attach a  to it, as well as other attributes: 
                        piecebehavior
                        transform, 
                        game-object, 
                        sprite,
                        color enum,
                        specialMove,
			
1. Ok we need to do some major refactoring. I want to have a class for each piece type, I want our controls to be an interface 
    -> I'm opting for an interface for the controls over an abstract class for the sake of possibly combining multiple controls for a piece (this would allow us to make more than just chess as a game)
        I think this is a good solution for this
    -> As for the class, I have a number of problems with this code. I want to accomplish a type of Model, View, Control design, where I abstract all of the information that is important for the game
    into a type of Model, which interfaces with the View. This way we could potentially have different types of client side representations of the chess game.

    -> Should we have a main class or an abstract gamepiece class that requires its members to have certain methods? What are the benefits / drawbacks of both?
        1. Presume we have one class for all of our chess pieces.... Would we write a new implementation for each? Not sure if C# even supports that kind of coding...
            -> Ultimately we need to have a different validation method for each piece, which would differentiate valid moves from invalid moves. Each piece should also probably have its own way of determining 
            if it is capturing a piece? Not 100% sure yet.

        2. Ok we have a system where we create a gamePiece, but not a specific chess piece. We still need to be able to differentiate
            -> So... next step will involve creating new classes for each piece, which we will index through a function that returns a class instantiation?
                -> i.e. GamePiece piece = someFunct(...);

        3. I'm considering whether or not to refactor the ChessData memory to store references to chess pieces instead of bytes for each piece. I'm 
            worried that the way we are currently handeling the ChessData elements is not going to scale well. It's performant to store this information
            in 2 bytes of data, but I am worried that this technique is ultimately not worth the memory savings...
                -> Not 100% sure of what I want to do with this yet.
                -> We could alternatively write an algorithm that returns the gamePiece object that is at the specific index. We could then keep the more performant
                data storing method.
                    -> It appears that since the enum is actually an int underneath all of the fluff, we are possibly gaining no performance benefits...
                    I'm somewhat confused as to how we are fitting all of these enums into our byte data. I feel like we should be overflowing the byte size..
                        -> I think we may not have attempted to cast a value that has the firstMove bit set, so we are always within the size of a true byte...

            